# Story 1.5: Configure Monitoring, Logging, and Metrics Exposure

Status: Ready for Review

## Story

As a developer,
I want structured logging with request tracing and MinIO metrics exposed,
So that I can monitor system health and troubleshoot issues effectively (FR62, NFR-M2, NFR-M3, NFR-M4).

## Acceptance Criteria

1. **Given** the platform is running, **When** API requests are processed, **Then** all logs are written in structured JSON format with fields: timestamp, level, request_id (UUID v4), user_id, message, context

2. **Given** an API request is received, **When** the request is processed, **Then** request_id is generated by middleware for every API request and included in all log entries

3. **Given** an API error occurs, **When** the error response is returned, **Then** request_id is included in API error responses for debugging (NFR-M8)

4. **Given** MinIO is running, **When** I access `:9000/minio/v2/metrics/cluster`, **Then** MinIO Prometheus metrics endpoint is accessible

5. **Given** MinIO metrics are exposed, **When** I query the metrics endpoint, **Then** MinIO metrics include storage usage, request rates, and error rates

6. **Given** a critical error occurs, **When** the error is logged, **Then** critical errors are logged with sufficient context including stack traces (NFR-M4)

7. **Given** the platform is deployed, **When** I configure the environment, **Then** log levels can be configured via environment variables (INFO for production, DEBUG for development)

## Tasks / Subtasks

- [x] Task 1: Create Request ID Middleware (AC: #1, #2, #3)
  - [x] 1.1 Create `backend/app/middleware/request_id.py` with request ID middleware
  - [x] 1.2 Generate UUID v4 for each incoming request
  - [x] 1.3 Store request_id in `request.state.request_id`
  - [x] 1.4 Add request_id to response headers as `X-Request-ID`
  - [x] 1.5 Register middleware in `backend/app/main.py`

- [x] Task 2: Implement Structured JSON Logging (AC: #1, #6, #7)
  - [x] 2.1 Create `backend/app/middleware/logging_config.py` with logging configuration
  - [x] 2.2 Configure Python `logging` module with JSON formatter
  - [x] 2.3 Create custom JSON formatter class with fields: timestamp, level, request_id, user_id, message, context
  - [x] 2.4 Add `LOG_LEVEL` environment variable to `backend/app/core/config.py`
  - [x] 2.5 Set log level from environment (default INFO, DEBUG for development)
  - [x] 2.6 Implement context injection (request_id, user_id) into all log entries
  - [x] 2.7 Add stack trace formatting for ERROR and CRITICAL level logs

- [x] Task 3: Create Logging Middleware (AC: #1, #2)
  - [x] 3.1 Create request/response logging middleware in `backend/app/middleware/logging_middleware.py`
  - [x] 3.2 Log incoming requests with: method, path, user_id (if authenticated), request_id
  - [x] 3.3 Log outgoing responses with: status_code, duration_ms, request_id
  - [x] 3.4 Extract user_id from JWT token when available
  - [x] 3.5 Register logging middleware in `backend/app/main.py`

- [x] Task 4: Update Error Response Format (AC: #3)
  - [x] 4.1 Update exception handlers in `backend/app/main.py` to include request_id
  - [x] 4.2 Ensure all error responses include request_id field in response body
  - [x] 4.3 Verify health check error responses include request_id
  - [x] 4.4 Update `backend/app/schemas/common.py` ErrorResponse schema to include request_id

- [x] Task 5: Configure MinIO Prometheus Metrics (AC: #4, #5)
  - [x] 5.1 Verify MinIO Prometheus metrics are enabled (default in MinIO)
  - [x] 5.2 Update `docker-compose.yml` to expose MinIO metrics port 9000 for metrics access
  - [x] 5.3 Add `MINIO_PROMETHEUS_AUTH_TYPE=public` environment variable for unauthenticated metrics access
  - [x] 5.4 Document metrics endpoint location: `:9000/minio/v2/metrics/cluster`
  - [x] 5.5 Test metrics endpoint returns Prometheus-formatted metrics

- [x] Task 6: Write Tests for Middleware (AC: #1-7)
  - [x] 6.1 Create `backend/tests/standalone/middleware/test_request_id.py`
  - [x] 6.2 Test request_id generation for each request
  - [x] 6.3 Test request_id included in response headers
  - [x] 6.4 Test structured log format output
  - [x] 6.5 Create `backend/tests/standalone/middleware/test_logging.py`
  - [x] 6.6 Test log level configuration from environment
  - [x] 6.7 Test error responses include request_id (test_error_responses.py)

- [x] Task 7: Update Environment Configuration (AC: #7)
  - [x] 7.1 Add `LOG_LEVEL` to `.env.example` with default value `INFO`
  - [x] 7.2 Add `LOG_FORMAT` environment variable (options: `json`, `text`) defaulting to `json`
  - [x] 7.3 Document logging configuration in code comments

## Dev Notes

### Architecture Compliance

**Layered Architecture Pattern:**
- Middleware layer: `backend/app/middleware/request_id.py`, `backend/app/middleware/logging.py`
- Core layer: `backend/app/core/config.py` for logging settings
- This follows the existing middleware pattern from the health check implementation

**Request ID Flow:**
```
Request → Request ID Middleware → Logging Middleware → Route Handler → Response
                ↓                      ↓                    ↓
         Generate UUID          Log with request_id    Include in error responses
                ↓
         Store in request.state.request_id
                ↓
         Add to response headers (X-Request-ID)
```

**Naming Conventions:**
- File names: snake_case (`request_id.py`, `logging.py`)
- Functions: snake_case (`get_request_id`, `setup_logging`)
- Classes: PascalCase (`JSONLogFormatter`, `RequestIDMiddleware`)
- Constants: UPPER_SNAKE_CASE (`LOG_LEVEL`, `LOG_FORMAT`)

### Technical Requirements

**Python Logging Configuration:**
- Use Python's built-in `logging` module
- Create custom `logging.Formatter` subclass for JSON output
- Use `structlog` library if additional features needed (optional)
- Configure root logger to use JSON formatter in production

**JSON Log Format (Target Output):**
```json
{
  "timestamp": "2025-12-15T10:30:00.123Z",
  "level": "INFO",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "660e8400-e29b-41d4-a716-446655440001",
  "message": "Request completed",
  "context": {
    "method": "GET",
    "path": "/api/v1/assets",
    "status_code": 200,
    "duration_ms": 45
  }
}
```

**Error Response Format (with request_id):**
```json
{
  "error_code": "ASSET_NOT_FOUND",
  "message": "Asset with ID 12345 does not exist",
  "details": {"asset_id": "12345"},
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-12-15T10:30:00Z"
}
```

**MinIO Prometheus Metrics:**
- Endpoint: `http://minio:9000/minio/v2/metrics/cluster`
- Format: Prometheus text format
- Key metrics to verify:
  - `minio_bucket_usage_total_bytes` - Storage usage
  - `minio_s3_requests_total` - Request rates
  - `minio_s3_requests_errors_total` - Error rates
  - `minio_node_process_uptime_seconds` - Uptime

### Current Codebase Context

**Existing Middleware Pattern (from Story 1.4):**
- Health router registered at root level in `backend/app/main.py`
- Middleware is added via `app.add_middleware()` or `@app.middleware("http")`

**Settings Pattern (from config.py):**
```python
class Settings(BaseSettings):
    # Existing settings...
    MINIO_ENDPOINT: str
    MINIO_ROOT_USER: str
    # Add new logging settings here
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "json"
```

**Exception Handling (from main.py):**
- Global exception handlers already exist
- Need to inject `request.state.request_id` into error responses

### File Structure Notes

**New Files to Create:**
```
backend/app/
├── middleware/
│   ├── __init__.py          # MODIFY: Export new middleware
│   ├── request_id.py        # NEW: Request ID generation middleware
│   └── logging.py           # NEW: JSON logging configuration
└── tests/
    └── middleware/
        ├── __init__.py      # NEW
        ├── test_request_id.py  # NEW
        └── test_logging.py     # NEW
```

**Files to Modify:**
```
backend/app/
├── core/
│   └── config.py            # MODIFY: Add LOG_LEVEL, LOG_FORMAT settings
├── main.py                  # MODIFY: Register middleware, update exception handlers
└── schemas/
    └── common.py            # MODIFY: Add request_id to ErrorResponse (if exists)
docker-compose.yml           # MODIFY: Add MINIO_PROMETHEUS_AUTH_TYPE env var
.env.example                 # MODIFY: Add LOG_LEVEL documentation
```

### References

- [Source: docs/epics.md#Story-1.5] - Original story requirements
- [Source: docs/architecture/core-architectural-decisions.md#Monitoring-Logging] - Structured JSON logging with request_id tracing
- [Source: docs/architecture/core-architectural-decisions.md#MinIO-Configuration] - Prometheus endpoint exposed by MinIO
- [Source: docs/architecture/implementation-patterns-consistency-rules.md#Communication-Patterns] - Request ID injection middleware pattern
- [Source: docs/architecture/project-structure-boundaries.md#Middleware] - Middleware file organization

### Previous Story Intelligence

**Story 1.4 Patterns (Health Check Implementation):**
- Used `asyncio.gather()` for concurrent async operations
- Used `asyncio.wait_for()` with timeout handling
- Logging for failures implemented with `logging.exception()`
- MinIO client already initialized in `backend/app/core/minio_client.py`
- Settings pattern uses Pydantic BaseSettings in `backend/app/core/config.py`

**Key Files from Previous Story:**
- `backend/app/core/config.py` - Settings class to extend
- `backend/app/main.py` - App initialization to add middleware
- `backend/app/api/routes/health.py` - Example of route registration

**Git Commit Patterns:**
- Conventional commits: `feat(story-1.X): Description`
- PR-based workflow to main branch

### Testing Standards

**Test Locations:**
- `backend/tests/middleware/test_request_id.py`
- `backend/tests/middleware/test_logging.py`

**Test Patterns:**
- Use pytest-asyncio for async middleware testing
- Use `TestClient` from FastAPI for integration tests
- Mock logging handlers to capture and verify log output
- Test both success and error scenarios

**Coverage Target:** 80% minimum per CI/CD pipeline

### Implementation Notes

**Middleware Registration Order:**
Middleware runs in LIFO order (last registered runs first on request, first on response).
Register in this order for proper request_id propagation:
1. Request ID Middleware (first - generates request_id)
2. Logging Middleware (second - uses request_id for logging)

**Async Middleware Pattern:**
```python
from starlette.middleware.base import BaseHTTPMiddleware

class RequestIDMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id
        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response
```

**JSON Formatter Pattern:**
```python
import json
import logging
from datetime import datetime

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": record.levelname,
            "message": record.getMessage(),
            "request_id": getattr(record, "request_id", None),
            "user_id": getattr(record, "user_id", None),
        }
        if record.exc_info:
            log_record["exception"] = self.formatException(record.exc_info)
        return json.dumps(log_record)
```

### Security Considerations

- Do NOT log sensitive data (passwords, tokens, PII)
- Sanitize request bodies before logging (exclude password fields)
- Log levels: INFO for request metadata, DEBUG for detailed debugging
- MinIO metrics endpoint should be internal-only in production (behind firewall)

## Dev Agent Record

### Context Reference

<!-- Path(s) to story context XML will be added here by context workflow -->

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

N/A - No critical errors during implementation.

### Completion Notes List

- **Task 1**: Created RequestIDMiddleware in `request_id.py` - generates UUID v4, stores in request.state, adds X-Request-ID header
- **Task 2**: Implemented JSONFormatter in `logging_config.py` - structured JSON output with timestamp, level, request_id, user_id, context, exception
- **Task 3**: Created LoggingMiddleware in `logging_middleware.py` - logs requests/responses with timing, sanitizes sensitive query params
- **Task 4**: Added exception handlers in `main.py` - HTTP, validation, and general exceptions all include request_id
- **Task 5**: Configured MinIO Prometheus metrics with `MINIO_PROMETHEUS_AUTH_TYPE=public`
- **Task 6**: Wrote 38 tests covering all acceptance criteria (TDD approach)
- **Task 7**: Updated `.env.example` with LOG_LEVEL and LOG_FORMAT configuration

### File List

**New Files:**
- `backend/app/middleware/request_id.py`
- `backend/app/middleware/logging_config.py`
- `backend/app/middleware/logging_middleware.py`
- `backend/app/schemas/common.py`
- `backend/tests/standalone/conftest.py`
- `backend/tests/standalone/middleware/test_request_id.py`
- `backend/tests/standalone/middleware/test_logging.py`
- `backend/tests/standalone/middleware/test_error_responses.py`

**Modified Files:**
- `backend/app/main.py` - Added middleware registration and exception handlers
- `backend/app/core/config.py` - Added LOG_LEVEL and LOG_FORMAT settings
- `docker-compose.yml` - Added MINIO_PROMETHEUS_AUTH_TYPE=public
- `.env.example` - Added logging configuration section
- `docs/sprint-artifacts/sprint-status.yaml` - Updated story status

// This file is auto-generated by @hey-api/openapi-ts

export const AssetResponseSchema = {
    properties: {
        asset_id: {
            type: 'string',
            format: 'uuid',
            title: 'Asset Id',
            description: 'Unique asset identifier'
        },
        file_name: {
            type: 'string',
            title: 'File Name',
            description: 'Original filename (sanitized)'
        },
        file_size_bytes: {
            type: 'integer',
            title: 'File Size Bytes',
            description: 'File size in bytes'
        },
        mime_type: {
            type: 'string',
            title: 'Mime Type',
            description: 'MIME type of the file'
        },
        checksum: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Checksum',
            description: 'MD5 checksum for integrity verification'
        },
        object_key: {
            type: 'string',
            title: 'Object Key',
            description: 'MinIO object key (storage path)'
        },
        bucket: {
            type: 'string',
            title: 'Bucket',
            description: 'MinIO bucket name'
        },
        user_id: {
            type: 'string',
            format: 'uuid',
            title: 'User Id',
            description: 'Owner user ID'
        },
        tenant_id: {
            type: 'string',
            format: 'uuid',
            title: 'Tenant Id',
            description: 'Tenant ID'
        },
        is_deleted: {
            type: 'boolean',
            title: 'Is Deleted',
            description: 'Soft delete flag'
        },
        created_at: {
            type: 'string',
            format: 'date-time',
            title: 'Created At',
            description: 'Upload timestamp'
        },
        updated_at: {
            type: 'string',
            format: 'date-time',
            title: 'Updated At',
            description: 'Last update timestamp'
        }
    },
    type: 'object',
    required: ['asset_id', 'file_name', 'file_size_bytes', 'mime_type', 'checksum', 'object_key', 'bucket', 'user_id', 'tenant_id', 'is_deleted', 'created_at', 'updated_at'],
    title: 'AssetResponse',
    description: `Response schema for asset operations (AC: #6).

Returned on successful upload with 201 Created.`,
    example: {
        asset_id: '550e8400-e29b-41d4-a716-446655440000',
        bucket: 'assets',
        checksum: 'd41d8cd98f00b204e9800998ecf8427e',
        created_at: '2025-12-17T10:30:00Z',
        file_name: 'textbook.pdf',
        file_size_bytes: 15728640,
        is_deleted: false,
        mime_type: 'application/pdf',
        object_key: 'publisher/tenant-123/asset-456/textbook.pdf',
        tenant_id: '770e8400-e29b-41d4-a716-446655440002',
        updated_at: '2025-12-17T10:30:00Z',
        user_id: '660e8400-e29b-41d4-a716-446655440001'
    }
} as const;

export const Body_assets_upload_fileSchema = {
    properties: {
        file: {
            type: 'string',
            format: 'binary',
            title: 'File',
            description: 'File to upload'
        }
    },
    type: 'object',
    required: ['file'],
    title: 'Body_assets-upload_file'
} as const;

export const Body_assets_upload_zipSchema = {
    properties: {
        file: {
            type: 'string',
            format: 'binary',
            title: 'File',
            description: 'ZIP archive to upload and extract'
        }
    },
    type: 'object',
    required: ['file'],
    title: 'Body_assets-upload_zip'
} as const;

export const Body_auth_loginSchema = {
    properties: {
        grant_type: {
            anyOf: [
                {
                    type: 'string',
                    pattern: 'password'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Grant Type'
        },
        username: {
            type: 'string',
            title: 'Username'
        },
        password: {
            type: 'string',
            title: 'Password'
        },
        scope: {
            type: 'string',
            title: 'Scope',
            default: ''
        },
        client_id: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Client Id'
        },
        client_secret: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Client Secret'
        }
    },
    type: 'object',
    required: ['username', 'password'],
    title: 'Body_auth-login'
} as const;

export const Body_login_login_access_tokenSchema = {
    properties: {
        grant_type: {
            anyOf: [
                {
                    type: 'string',
                    pattern: 'password'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Grant Type'
        },
        username: {
            type: 'string',
            title: 'Username'
        },
        password: {
            type: 'string',
            title: 'Password'
        },
        scope: {
            type: 'string',
            title: 'Scope',
            default: ''
        },
        client_id: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Client Id'
        },
        client_secret: {
            anyOf: [
                {
                    type: 'string'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Client Secret'
        }
    },
    type: 'object',
    required: ['username', 'password'],
    title: 'Body_login-login_access_token'
} as const;

export const ExtensionMappingSchema = {
    properties: {
        extension: {
            type: 'string',
            title: 'Extension',
            description: "File extension (e.g., '.pdf')"
        },
        mime_types: {
            items: {
                type: 'string'
            },
            type: 'array',
            title: 'Mime Types',
            description: 'Allowed MIME types for this extension'
        }
    },
    type: 'object',
    required: ['extension', 'mime_types'],
    title: 'ExtensionMapping',
    description: 'Extension to MIME type mapping.'
} as const;

export const FailedFileInfoSchema = {
    properties: {
        file_name: {
            type: 'string',
            title: 'File Name',
            description: 'Name of the failed file'
        },
        error_code: {
            type: 'string',
            title: 'Error Code',
            description: 'Machine-readable error code'
        },
        message: {
            type: 'string',
            title: 'Message',
            description: 'Human-readable error message'
        }
    },
    type: 'object',
    required: ['file_name', 'error_code', 'message'],
    title: 'FailedFileInfo',
    description: 'Information about a file that failed validation during ZIP extraction.',
    example: {
        error_code: 'INVALID_FILE_TYPE',
        file_name: 'virus.exe',
        message: "File type 'application/x-msdownload' is not allowed"
    }
} as const;

export const HTTPValidationErrorSchema = {
    properties: {
        detail: {
            items: {
                '$ref': '#/components/schemas/ValidationError'
            },
            type: 'array',
            title: 'Detail'
        }
    },
    type: 'object',
    title: 'HTTPValidationError'
} as const;

export const HealthCheckResponseSchema = {
    properties: {
        status: {
            type: 'string',
            enum: ['healthy', 'unhealthy'],
            title: 'Status'
        },
        database: {
            type: 'string',
            enum: ['ok', 'error'],
            title: 'Database'
        },
        minio: {
            type: 'string',
            enum: ['ok', 'error'],
            title: 'Minio'
        },
        timestamp: {
            type: 'string',
            format: 'date-time',
            title: 'Timestamp'
        }
    },
    type: 'object',
    required: ['status', 'database', 'minio', 'timestamp'],
    title: 'HealthCheckResponse',
    description: 'Health check response schema.'
} as const;

export const ItemCreateSchema = {
    properties: {
        title: {
            type: 'string',
            maxLength: 255,
            minLength: 1,
            title: 'Title'
        },
        description: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Description'
        }
    },
    type: 'object',
    required: ['title'],
    title: 'ItemCreate',
    description: 'Properties to receive on item creation.'
} as const;

export const ItemPublicSchema = {
    properties: {
        title: {
            type: 'string',
            maxLength: 255,
            minLength: 1,
            title: 'Title'
        },
        description: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Description'
        },
        id: {
            type: 'string',
            format: 'uuid',
            title: 'Id'
        },
        owner_id: {
            type: 'string',
            format: 'uuid',
            title: 'Owner Id'
        }
    },
    type: 'object',
    required: ['title', 'id', 'owner_id'],
    title: 'ItemPublic',
    description: 'Properties to return via API.'
} as const;

export const ItemUpdateSchema = {
    properties: {
        title: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255,
                    minLength: 1
                },
                {
                    type: 'null'
                }
            ],
            title: 'Title'
        },
        description: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Description'
        }
    },
    type: 'object',
    title: 'ItemUpdate',
    description: 'Properties to receive on item update.'
} as const;

export const ItemsPublicSchema = {
    properties: {
        data: {
            items: {
                '$ref': '#/components/schemas/ItemPublic'
            },
            type: 'array',
            title: 'Data'
        },
        count: {
            type: 'integer',
            title: 'Count'
        }
    },
    type: 'object',
    required: ['data', 'count'],
    title: 'ItemsPublic',
    description: 'Paginated list of items.'
} as const;

export const MessageSchema = {
    properties: {
        message: {
            type: 'string',
            title: 'Message'
        }
    },
    type: 'object',
    required: ['message'],
    title: 'Message',
    description: 'Generic message response.'
} as const;

export const NewPasswordSchema = {
    properties: {
        token: {
            type: 'string',
            title: 'Token'
        },
        new_password: {
            type: 'string',
            maxLength: 128,
            minLength: 8,
            title: 'New Password'
        }
    },
    type: 'object',
    required: ['token', 'new_password'],
    title: 'NewPassword',
    description: 'Properties for password reset.'
} as const;

export const PrivateUserCreateSchema = {
    properties: {
        email: {
            type: 'string',
            title: 'Email'
        },
        password: {
            type: 'string',
            title: 'Password'
        },
        full_name: {
            type: 'string',
            title: 'Full Name'
        },
        is_verified: {
            type: 'boolean',
            title: 'Is Verified',
            default: false
        }
    },
    type: 'object',
    required: ['email', 'password', 'full_name'],
    title: 'PrivateUserCreate'
} as const;

export const RefreshTokenRequestSchema = {
    properties: {
        refresh_token: {
            type: 'string',
            title: 'Refresh Token'
        }
    },
    type: 'object',
    required: ['refresh_token'],
    title: 'RefreshTokenRequest',
    description: 'Request body for token refresh endpoint (AC: #7).'
} as const;

export const SignedURLResponseSchema = {
    properties: {
        url: {
            type: 'string',
            title: 'Url',
            description: 'Presigned URL for direct MinIO access'
        },
        expires_at: {
            type: 'string',
            format: 'date-time',
            title: 'Expires At',
            description: 'URL expiration time (ISO-8601)'
        },
        type: {
            type: 'string',
            enum: ['download', 'upload', 'stream'],
            title: 'Type',
            description: 'Type of signed URL operation'
        }
    },
    type: 'object',
    required: ['url', 'expires_at', 'type'],
    title: 'SignedURLResponse',
    description: `Response schema for signed URL generation (AC: #9).

Returned when a presigned URL is successfully generated.`,
    example: {
        expires_at: '2025-12-17T12:00:00Z',
        type: 'download',
        url: 'http://minio:9000/assets/publisher/tenant-id/asset-id/file.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=...'
    }
} as const;

export const SizeLimitInfoSchema = {
    properties: {
        category: {
            type: 'string',
            title: 'Category',
            description: 'File category (video, image, audio, default)'
        },
        max_size_bytes: {
            type: 'integer',
            title: 'Max Size Bytes',
            description: 'Maximum file size in bytes'
        },
        max_size_human: {
            type: 'string',
            title: 'Max Size Human',
            description: "Human-readable size limit (e.g., '10 GB')"
        }
    },
    type: 'object',
    required: ['category', 'max_size_bytes', 'max_size_human'],
    title: 'SizeLimitInfo',
    description: 'Size limit information for a file category.'
} as const;

export const SkippedFileInfoSchema = {
    properties: {
        file_name: {
            type: 'string',
            title: 'File Name',
            description: 'Name of the skipped file'
        },
        reason: {
            type: 'string',
            title: 'Reason',
            description: 'Reason for skipping: system_file, directory, empty_file, path_traversal'
        }
    },
    type: 'object',
    required: ['file_name', 'reason'],
    title: 'SkippedFileInfo',
    description: 'Information about a file skipped during ZIP extraction.',
    example: {
        file_name: '.DS_Store',
        reason: 'system_file'
    }
} as const;

export const TokenSchema = {
    properties: {
        access_token: {
            type: 'string',
            title: 'Access Token'
        },
        token_type: {
            type: 'string',
            title: 'Token Type',
            default: 'bearer'
        }
    },
    type: 'object',
    required: ['access_token'],
    title: 'Token',
    description: 'JSON payload containing access token (legacy, for backward compatibility).'
} as const;

export const TokenResponseSchema = {
    properties: {
        access_token: {
            type: 'string',
            title: 'Access Token'
        },
        refresh_token: {
            type: 'string',
            title: 'Refresh Token'
        },
        token_type: {
            type: 'string',
            title: 'Token Type',
            default: 'bearer'
        },
        expires_in: {
            type: 'integer',
            title: 'Expires In'
        }
    },
    type: 'object',
    required: ['access_token', 'refresh_token', 'expires_in'],
    title: 'TokenResponse',
    description: 'Full token response with access and refresh tokens (AC: #1, #7).'
} as const;

export const UpdatePasswordSchema = {
    properties: {
        current_password: {
            type: 'string',
            maxLength: 128,
            minLength: 8,
            title: 'Current Password'
        },
        new_password: {
            type: 'string',
            maxLength: 128,
            minLength: 8,
            title: 'New Password'
        }
    },
    type: 'object',
    required: ['current_password', 'new_password'],
    title: 'UpdatePassword',
    description: 'Properties for password update.'
} as const;

export const UploadURLRequestSchema = {
    properties: {
        file_name: {
            type: 'string',
            maxLength: 255,
            title: 'File Name',
            description: 'Name of the file to upload'
        },
        mime_type: {
            type: 'string',
            maxLength: 127,
            title: 'Mime Type',
            description: 'MIME type of the file'
        },
        file_size: {
            type: 'integer',
            exclusiveMinimum: 0,
            title: 'File Size',
            description: 'Size of the file in bytes'
        }
    },
    type: 'object',
    required: ['file_name', 'mime_type', 'file_size'],
    title: 'UploadURLRequest',
    description: `Request schema for presigned upload URL generation.

Validates file_name and mime_type before generating upload URL.`,
    example: {
        file_name: 'textbook.pdf',
        file_size: 15728640,
        mime_type: 'application/pdf'
    }
} as const;

export const UploadURLResponseSchema = {
    properties: {
        url: {
            type: 'string',
            title: 'Url',
            description: 'Presigned URL for direct MinIO upload'
        },
        expires_at: {
            type: 'string',
            format: 'date-time',
            title: 'Expires At',
            description: 'URL expiration time (ISO-8601)'
        },
        type: {
            type: 'string',
            const: 'upload',
            title: 'Type',
            description: 'URL type',
            default: 'upload'
        },
        asset_id: {
            type: 'string',
            format: 'uuid',
            title: 'Asset Id',
            description: 'Pre-generated asset ID for the upload'
        },
        object_key: {
            type: 'string',
            title: 'Object Key',
            description: 'MinIO object key where file will be stored'
        }
    },
    type: 'object',
    required: ['url', 'expires_at', 'asset_id', 'object_key'],
    title: 'UploadURLResponse',
    description: `Response schema for presigned upload URL generation.

Includes the upload URL, expiration, and the asset_id for the new asset.`,
    example: {
        asset_id: '550e8400-e29b-41d4-a716-446655440000',
        expires_at: '2025-12-17T10:15:00Z',
        object_key: 'publisher/tenant-id/asset-id/file.pdf',
        type: 'upload',
        url: 'http://minio:9000/assets/publisher/tenant-id/asset-id/file.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=...'
    }
} as const;

export const UserCreateSchema = {
    properties: {
        email: {
            type: 'string',
            maxLength: 255,
            format: 'email',
            title: 'Email'
        },
        is_active: {
            type: 'boolean',
            title: 'Is Active',
            default: true
        },
        is_superuser: {
            type: 'boolean',
            title: 'Is Superuser',
            default: false
        },
        full_name: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Full Name'
        },
        role: {
            '$ref': '#/components/schemas/UserRole',
            default: 'student'
        },
        password: {
            type: 'string',
            maxLength: 128,
            minLength: 8,
            title: 'Password'
        },
        tenant_id: {
            anyOf: [
                {
                    type: 'string',
                    format: 'uuid'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Tenant Id'
        }
    },
    type: 'object',
    required: ['email', 'password'],
    title: 'UserCreate',
    description: 'Properties to receive via API on user creation.'
} as const;

export const UserPublicSchema = {
    properties: {
        email: {
            type: 'string',
            maxLength: 255,
            format: 'email',
            title: 'Email'
        },
        is_active: {
            type: 'boolean',
            title: 'Is Active',
            default: true
        },
        is_superuser: {
            type: 'boolean',
            title: 'Is Superuser',
            default: false
        },
        full_name: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Full Name'
        },
        role: {
            '$ref': '#/components/schemas/UserRole',
            default: 'student'
        },
        id: {
            type: 'string',
            format: 'uuid',
            title: 'Id'
        },
        tenant_id: {
            anyOf: [
                {
                    type: 'string',
                    format: 'uuid'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Tenant Id'
        },
        created_at: {
            type: 'string',
            format: 'date-time',
            title: 'Created At'
        },
        updated_at: {
            type: 'string',
            format: 'date-time',
            title: 'Updated At'
        }
    },
    type: 'object',
    required: ['email', 'id', 'tenant_id', 'created_at', 'updated_at'],
    title: 'UserPublic',
    description: 'Properties to return via API.'
} as const;

export const UserRegisterSchema = {
    properties: {
        email: {
            type: 'string',
            maxLength: 255,
            format: 'email',
            title: 'Email'
        },
        password: {
            type: 'string',
            maxLength: 128,
            minLength: 8,
            title: 'Password'
        },
        full_name: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Full Name'
        }
    },
    type: 'object',
    required: ['email', 'password'],
    title: 'UserRegister',
    description: 'Properties for user self-registration.'
} as const;

export const UserRoleSchema = {
    type: 'string',
    enum: ['admin', 'supervisor', 'publisher', 'school', 'teacher', 'student'],
    title: 'UserRole',
    description: 'User roles for role-based access control (RBAC).'
} as const;

export const UserUpdateSchema = {
    properties: {
        email: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255,
                    format: 'email'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Email'
        },
        is_active: {
            type: 'boolean',
            title: 'Is Active',
            default: true
        },
        is_superuser: {
            type: 'boolean',
            title: 'Is Superuser',
            default: false
        },
        full_name: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Full Name'
        },
        role: {
            anyOf: [
                {
                    '$ref': '#/components/schemas/UserRole'
                },
                {
                    type: 'null'
                }
            ]
        },
        password: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 128,
                    minLength: 8
                },
                {
                    type: 'null'
                }
            ],
            title: 'Password'
        },
        tenant_id: {
            anyOf: [
                {
                    type: 'string',
                    format: 'uuid'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Tenant Id'
        }
    },
    type: 'object',
    title: 'UserUpdate',
    description: 'Properties to receive via API on user update, all optional.'
} as const;

export const UserUpdateMeSchema = {
    properties: {
        full_name: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255
                },
                {
                    type: 'null'
                }
            ],
            title: 'Full Name'
        },
        email: {
            anyOf: [
                {
                    type: 'string',
                    maxLength: 255,
                    format: 'email'
                },
                {
                    type: 'null'
                }
            ],
            title: 'Email'
        }
    },
    type: 'object',
    title: 'UserUpdateMe',
    description: 'Properties for user to update their own profile.'
} as const;

export const UsersPublicSchema = {
    properties: {
        data: {
            items: {
                '$ref': '#/components/schemas/UserPublic'
            },
            type: 'array',
            title: 'Data'
        },
        count: {
            type: 'integer',
            title: 'Count'
        }
    },
    type: 'object',
    required: ['data', 'count'],
    title: 'UsersPublic',
    description: 'Paginated list of users.'
} as const;

export const ValidationErrorSchema = {
    properties: {
        loc: {
            items: {
                anyOf: [
                    {
                        type: 'string'
                    },
                    {
                        type: 'integer'
                    }
                ]
            },
            type: 'array',
            title: 'Location'
        },
        msg: {
            type: 'string',
            title: 'Message'
        },
        type: {
            type: 'string',
            title: 'Error Type'
        }
    },
    type: 'object',
    required: ['loc', 'msg', 'type'],
    title: 'ValidationError'
} as const;

export const ValidationRulesResponseSchema = {
    properties: {
        allowed_mime_types: {
            items: {
                type: 'string'
            },
            type: 'array',
            title: 'Allowed Mime Types',
            description: 'List of allowed MIME types'
        },
        size_limits: {
            items: {
                '$ref': '#/components/schemas/SizeLimitInfo'
            },
            type: 'array',
            title: 'Size Limits',
            description: 'Size limits per file category'
        },
        extension_mappings: {
            items: {
                '$ref': '#/components/schemas/ExtensionMapping'
            },
            type: 'array',
            title: 'Extension Mappings',
            description: 'Extension to MIME type mappings'
        },
        max_filename_length: {
            type: 'integer',
            title: 'Max Filename Length',
            description: 'Maximum allowed filename length'
        },
        dangerous_extensions: {
            items: {
                type: 'string'
            },
            type: 'array',
            title: 'Dangerous Extensions',
            description: 'Extensions that are always blocked'
        }
    },
    type: 'object',
    required: ['allowed_mime_types', 'size_limits', 'extension_mappings', 'max_filename_length', 'dangerous_extensions'],
    title: 'ValidationRulesResponse',
    description: `Response containing all file validation rules (Story 3.4, AC: #8).

Use this to:
- Show allowed file types in upload UI
- Validate files before upload attempt
- Display size limits to users
- Build file type filters for file picker`,
    example: {
        allowed_mime_types: ['application/pdf', 'video/mp4', 'image/jpeg', 'audio/mpeg'],
        dangerous_extensions: ['.exe', '.bat', '.cmd', '.com', '.msi'],
        extension_mappings: [
            {
                extension: '.pdf',
                mime_types: ['application/pdf']
            },
            {
                extension: '.mp4',
                mime_types: ['video/mp4']
            },
            {
                extension: '.jpg',
                mime_types: ['image/jpeg']
            }
        ],
        max_filename_length: 255,
        size_limits: [
            {
                category: 'video',
                max_size_bytes: 10737418240,
                max_size_human: '10 GB'
            },
            {
                category: 'image',
                max_size_bytes: 524288000,
                max_size_human: '500 MB'
            },
            {
                category: 'audio',
                max_size_bytes: 104857600,
                max_size_human: '100 MB'
            },
            {
                category: 'default',
                max_size_bytes: 5368709120,
                max_size_human: '5 GB'
            }
        ]
    }
} as const;

export const ZipUploadResponseSchema = {
    properties: {
        extracted_count: {
            type: 'integer',
            title: 'Extracted Count',
            description: 'Number of files successfully extracted and uploaded'
        },
        skipped_count: {
            type: 'integer',
            title: 'Skipped Count',
            description: 'Number of files skipped (system files, directories)'
        },
        failed_count: {
            type: 'integer',
            title: 'Failed Count',
            description: 'Number of files that failed validation'
        },
        total_size_bytes: {
            type: 'integer',
            title: 'Total Size Bytes',
            description: 'Total size of all extracted files in bytes'
        },
        assets: {
            items: {
                '$ref': '#/components/schemas/AssetResponse'
            },
            type: 'array',
            title: 'Assets',
            description: 'List of created asset records for extracted files'
        },
        skipped_files: {
            items: {
                '$ref': '#/components/schemas/SkippedFileInfo'
            },
            type: 'array',
            title: 'Skipped Files',
            description: 'Details of files skipped during extraction'
        },
        failed_files: {
            items: {
                '$ref': '#/components/schemas/FailedFileInfo'
            },
            type: 'array',
            title: 'Failed Files',
            description: 'Details of files that failed validation'
        }
    },
    type: 'object',
    required: ['extracted_count', 'skipped_count', 'failed_count', 'total_size_bytes', 'assets', 'skipped_files', 'failed_files'],
    title: 'ZipUploadResponse',
    description: `Response schema for ZIP archive upload (AC: #10).

Returned on successful ZIP extraction with 201 Created.
Contains counts and details of extracted, skipped, and failed files.`,
    example: {
        assets: [
            {
                asset_id: '550e8400-e29b-41d4-a716-446655440000',
                bucket: 'assets',
                checksum: 'd41d8cd98f00b204e9800998ecf8427e',
                created_at: '2025-12-17T10:30:00Z',
                file_name: 'document.pdf',
                file_size_bytes: 1048576,
                is_deleted: false,
                mime_type: 'application/pdf',
                object_key: 'publisher/tenant-123/asset-456/document.pdf',
                tenant_id: '770e8400-e29b-41d4-a716-446655440002',
                updated_at: '2025-12-17T10:30:00Z',
                user_id: '660e8400-e29b-41d4-a716-446655440001'
            }
        ],
        extracted_count: 15,
        failed_count: 1,
        failed_files: [
            {
                error_code: 'INVALID_FILE_TYPE',
                file_name: 'malware.exe',
                message: "File type 'application/x-msdownload' is not allowed"
            }
        ],
        skipped_count: 3,
        skipped_files: [
            {
                file_name: '.DS_Store',
                reason: 'system_file'
            },
            {
                file_name: '__MACOSX/._document.pdf',
                reason: 'system_file'
            },
            {
                file_name: 'images/',
                reason: 'directory'
            }
        ],
        total_size_bytes: 52428800
    }
} as const;